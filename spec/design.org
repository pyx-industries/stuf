#+TITLE: STUF Authentication and Authorization Design
#+AUTHOR: Pyx.io Team
#+DATE: 2025-08-25

* Authentication and Authorization Design

** Authorization Server and STUF Domain Relationship

The STUF system implements a 1:1 mapping between OIDC Authorization Servers and STUF domains:

- Each STUF domain (a distinct upload facility created by a Trust Architect) corresponds to exactly one OIDC Authorization Server (implemented as a Keycloak realm)
- Each access token is issued by exactly one authorization server and can only be used within that domain
- The "iss" (issuer) claim in the access token identifies the specific authorization server that issued the token

This 1:1 mapping ensures proper isolation between different STUF instances and simplifies the authorization model.

*** Technical Implementation

When a Trust Architect creates a new STUF domain:

1. A new OIDC Authorization Server is automatically created (implemented as a Keycloak realm)
2. OIDC clients for the SPA (public client) and API (confidential client) are configured within this authorization server
3. The authorization server's issuer URL becomes part of the token verification process
4. All authentication and authorization for this STUF domain happens within this authorization server

The API and SPA are configured to only accept access tokens from their specific authorization server, ensuring that a token issued for one STUF domain cannot be used to access resources in another STUF domain.

** Authorization Structure

Each STUF domain (authorization server) implements a dynamic authorization model using OIDC scopes and custom claims:

*** Required Scopes

- **openid**: Standard OIDC scope for authentication
- **myapp:access**: Application-specific scope for STUF access

*** Admin Authorization

- Trust Architects are granted an "admin" role via custom claims
- The admin role grants:
  - Full access to all collections within the domain
  - Ability to configure metadata requirements
  - User management capabilities
  - Access to all uploaded files
  - Configuration management for the domain

*** Collection Permissions

- Collection access is granted via a custom `collections` claim in access tokens
- Collections are discovered dynamically from the token claims (no hardcoded collection names)
- Each collection permission specifies granular access levels:
  - **read**: View collection contents and download files
  - **write**: Upload files to the collection
  - **delete**: Remove files from the collection
- Project Participants receive collection permissions based on their assigned roles/groups

*** Permission Assignment

- Trust Architects (with admin role) can assign collection permissions to Project Participants
- A Project Participant can have permissions for multiple collections with different access levels
- Permission assignments are stored in the authorization server and included in access token claims

** Authentication and Authorization Flow

*** Authentication Flow (OIDC)

1. User initiates login in SPA â†’ redirected to authorization server
2. User authenticates via OIDC Authorization Code flow with PKCE
3. Authorization server issues access token containing:
   - The authorization server's issuer URL
   - Required scopes (openid, myapp:access)
   - Custom claims including admin role and collections permissions
   - Standard token metadata (expiration, audience, etc.)
4. SPA receives and securely stores the access token

*** Authorization Flow (API Access)

1. SPA extracts collection permissions from access token claims
2. SPA dynamically renders UI based on discovered collections and permissions
3. SPA makes API requests with `Authorization: Bearer {token}` header
4. API verifies the access token by:
   - Validating JWT signature against authorization server's public keys
   - Checking token expiration and audience claims
   - Confirming token was issued by the correct authorization server
5. API extracts and parses the `collections` claim for permission checking
6. API grants or denies access based on the specific permissions in the token
7. For non-existent collections, API creates them on-demand if user has appropriate permissions

** Benefits of This Design

- **IDP Agnostic**: Works with any OIDC-compliant authorization server (Keycloak, AWS Cognito, Azure Entra ID, etc.)
- **Clear Domain Separation**: Secure isolation between different STUF domains via authorization server boundaries
- **Dynamic Collection Discovery**: No hardcoded collections - all collections discovered from token claims at runtime
- **Granular Permissions**: Fine-grained read/write/delete permissions per collection
- **On-Demand Collection Creation**: Collections created automatically when authorized users access them
- **Standards Compliant**: Uses proper OIDC/OAuth2 terminology and flows
- **Flexible Authorization**: Trust authorization server as source of truth for collection existence and permissions
- **Secure Token Handling**: Proper token verification with signature validation and expiration checking
